# Docker Documentation: From Scratch to Expert

## Introduction to Docker

Docker is an open-source platform that automates the deployment, scaling, and management of applications using containerization. Containers package an application and its dependencies into a single, portable unit that can run consistently across different environments.

### Why Use Docker?

- Consistency across multiple development, testing, and production environments.
- Lightweight and fast compared to traditional virtual machines.
- Simplifies application deployment and scaling.
- Enables microservices architecture and DevOps practices.

---

## Installation and Setup

### Installing Docker

- **Windows and macOS:** Download Docker Desktop from [https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop) and follow the installation instructions.
- **Linux:** Install Docker Engine using your distribution’s package manager. For example, on Ubuntu:

```bash
sudo apt-get update
sudo apt-get install docker-ce docker-ce-cli containerd.io
```

### Verify Installation

Run the following command to verify Docker is installed correctly:

```bash
docker --version
```

---

## Docker Architecture and Components

- **Docker Engine:** The core component that creates and runs containers.
- **Docker Images:** Read-only templates used to create containers.
- **Docker Containers:** Running instances of Docker images.
- **Docker Hub:** A cloud-based registry for sharing Docker images.
- **Dockerfile:** A script containing instructions to build Docker images.
- **Docker Compose:** A tool for defining and running multi-container Docker applications.
- **Docker Swarm:** Native clustering and orchestration tool for Docker.

---

## Basic Docker Commands

- `docker run`: Run a container from an image.
- `docker ps`: List running containers.
- `docker ps -a`: List all containers.
- `docker stop`: Stop a running container.
- `docker rm`: Remove a container.
- `docker images`: List images.
- `docker rmi`: Remove an image.
- `docker pull`: Download an image from a registry.
- `docker push`: Upload an image to a registry.
- `docker commit`: Create a new image from a container’s changes.
- `docker tag`: Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE.

---

## Working with Docker Images and Containers

### Pulling an Image

```bash
docker pull nginx
```

### Running a Container

```bash
docker run -d -p 80:80 nginx
```

### Accessing a Container

```bash
docker exec -it <container_id> /bin/bash
```

### Stopping and Removing Containers

```bash
docker stop <container_id>
docker rm <container_id>
```

---

## Docker Networking

- **Bridge Network:** Default network for containers on a single host.
- **Host Network:** Containers share the host’s network stack.
- **Overlay Network:** Enables communication between containers across multiple Docker hosts.
- **Macvlan Network:** Assigns a MAC address to a container, making it appear as a physical device on the network.

---

## Docker Volumes and Storage

- Volumes are used to persist data generated by and used by Docker containers.
- Create a volume:

```bash
docker volume create my_volume
```

- Use a volume in a container:

```bash
docker run -d -v /host/path/my_volume:/data nginx
```
docker run -d -v /host/path/my_volume:/data nginx

---

## Docker Compose

Docker Compose allows defining and running multi-container Docker applications using a YAML file.

### Example `docker-compose.yml`

```yaml
version: '3'
services:
  web:
    image: nginx
    ports:
      - "80:80"
  db:
    image: mysql
    environment:
      MYSQL_ROOT_PASSWORD: example
```

### Commands

- `docker-compose up`: Start services.
- `docker-compose down`: Stop and remove services.

---

## Dockerfile and Building Images

A Dockerfile is a text file with instructions to build a Docker image.

### Example Dockerfile

```dockerfile
FROM python:3.8-slim
WORKDIR /app
COPY . /app
RUN pip install -r requirements.txt
CMD ["python", "app.py"]
```

### Build and Run

```bash
docker build -t my-python-app .
docker run -d -p 5000:5000 my-python-app
```

---

## Docker Swarm and Orchestration Basics

Docker Swarm enables clustering and orchestration of Docker containers.

- Initialize a swarm:

```bash
docker swarm init
```

- Deploy a service:

```bash
docker service create --name web -p 80:80 nginx
```

- List services:

```bash
docker service ls
```

---

## Best Practices and Security

- Use official images or trusted sources.
- Keep images small and efficient.
- Regularly update images and containers.
- Use multi-stage builds to optimize Dockerfiles.
- Limit container privileges.
- Scan images for vulnerabilities.
- Use secrets management for sensitive data.

---

## Advanced Topics and Resources

- Docker Plugins and Extensions
- Kubernetes Integration
- CI/CD with Docker
- Monitoring and Logging
- Docker API and SDKs

### Resources

- Official Docker Documentation: [https://docs.docker.com/](https://docs.docker.com/)
- Docker Hub: [https://hub.docker.com/](https://hub.docker.com/)
- Docker GitHub Repository: [https://github.com/docker](https://github.com/docker)

---

This documentation provides a comprehensive guide to learning Docker from beginner to expert level.

---

## Additional Docker Notes

### 1. What is Docker? History and Development

Docker was developed by Solomon Hykes and released by Docker, Inc. in 2013. It revolutionized software development by introducing containerization technology that allows applications to run in isolated environments called containers.

### 2. Why Do We Need Docker? Purpose

- To simplify application deployment and ensure consistency across different environments (development, testing, production).
- To enable faster and more efficient software delivery through containerization.
- To support microservices architecture by isolating services in containers.
- To reduce overhead compared to traditional virtual machines.

### 3. How Does Docker Work?

Docker uses OS-level virtualization to run multiple containers on a single host OS kernel. Each container shares the host OS kernel but runs in isolated user spaces. Docker Engine manages container lifecycle, images, networking, and storage.

### 4. Docker and Microservices

Docker is widely used to implement microservices architecture by packaging each microservice in its own container. This isolation allows independent deployment, scaling, and management of services.

### 5. Problems Before Docker

Before Docker, developers used virtual machines or manual environment setups, which were resource-heavy, slow to start, and prone to inconsistencies across environments.

### 6. Diagram

```
+---------------------+
|      Host OS        |
| +-----------------+ |
| | Docker Engine   | |
| | +-------------+ | |
| | | Container 1 | | |
| | +-------------+ | |
| | +-------------+ | |
| | | Container 2 | | |
| | +-------------+ | |
| +-----------------+ |
+---------------------+
```

### 7. What is a Hypervisor?

A hypervisor is software that creates and runs virtual machines by abstracting hardware resources. It enables hardware-level virtualization.

### 8. Types of Hypervisors

- Type 1 (Bare-metal): Runs directly on the host's hardware (e.g., VMware ESXi, Microsoft Hyper-V).
- Type 2 (Hosted): Runs on top of a host OS (e.g., VirtualBox, VMware Workstation).

### 9. Explanation of Types

- Type 1 hypervisors offer better performance and security as they run directly on hardware.
- Type 2 hypervisors are easier to set up but have more overhead due to running on a host OS.

### 10. What is a Containerized Engine?

A containerized engine (like Docker Engine) manages containers by leveraging OS-level virtualization, providing lightweight, fast, and portable environments.

### 11. OS-level Virtualization

OS-level virtualization allows multiple isolated user-space instances (containers) to run on a single OS kernel.

### 12. Hardware-level Virtualization

Hardware-level virtualization uses hypervisors to create full virtual machines with separate OS instances on shared hardware.

### 13. Advantages and Disadvantages

| Environment       | Advantages                              | Disadvantages                         |
|-------------------|-------------------------------------|-------------------------------------|
| Bare Metal        | High performance, direct hardware access | Less flexible, harder to manage     |
| Virtualization    | Isolation, multiple OS instances     | Higher resource usage, slower startup |
| Containerization  | Lightweight, fast startup, portable  | Less isolation than VMs, shared kernel |

### 14. Docker Modes and Options

- `-d` : Detached mode, runs container in background.
- `-it`: Interactive mode with terminal.
- `--rm`: Automatically remove container when it exits.
- `-p`: Publish container ports to host.
- `-v`: Mount volumes.
- `--name`: Assign a name to the container.

### 15. Practical: Running httpd on Docker

```bash
docker run -d -p 80:80 httpd
```

- httpd home path inside container: `/usr/local/apache2/`

### 16. HTML Path in Nginx

- Default HTML path inside nginx container: `/usr/share/nginx/html`

### 17. Common Docker Commands

- `docker run`: Run a container.
- `docker ps`: List running containers.
- `docker ps -a`: List all containers.
- `docker stop`: Stop a container.
- `docker rm`: Remove a container.
- `docker images`: List images.
- `docker rmi`: Remove an image.
- `docker pull`: Download image.
- `docker push`: Upload image.
- `docker exec`: Run command in container.

### 18. Common Docker Errors

- "Cannot connect to the Docker daemon": Docker service not running or permission issues.
- "Image not found": Image name or tag incorrect.
- "Port already allocated": Port conflict on host.
- "Permission denied": File or volume permission issues.

### 19. Docker Volumes: What, Why, When

Docker Volumes are a mechanism for persisting data generated and used by Docker containers. They allow data to exist beyond the lifecycle of a container, enabling data sharing and persistence.

- Why we need volumes:
  - To persist data beyond container restarts or removals.
  - To share data between containers.
  - To decouple storage from container lifecycle.
  - To improve performance and manageability compared to storing data inside containers.

- Types of volumes:
  1. **Volume Mounts**: Managed by Docker and stored in a part of the host filesystem managed by Docker (`/var/lib/docker/volumes/` on Linux). These volumes are portable and can be easily backed up or migrated.
     - Purpose: Provide persistent, managed storage independent of the host filesystem structure.
     - When to use: For most persistent data needs where portability and Docker management are desired.
  2. **Bind Mounts**: Map a file or directory on the host machine into the container. The host directory/file is directly accessed by the container.
     - Purpose: Allow containers to use existing host files or directories.
     - When to use: For development scenarios where live code or configuration files need to be shared, or when specific host paths must be accessed.

- Choosing volume types:
  - Use **Volume Mounts** for production data persistence and when you want Docker to manage the storage.
  - Use **Bind Mounts** for development, debugging, or when you need direct access to host files.


### 20. Monolithic vs Microservices

- Monolithic: Single unified application.
- Microservices: Application split into small, independent services communicating over network.

---
